/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.3.1
 * Sat, 08 Jul 2023 11:01:54 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables/constants used by puzzles' functions

var LIST_NONE = '<none>';

var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

var PL = {};
// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}

// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}



// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = false;
_initGlob.output.initOptions.useBkgTransp = true;
_initGlob.output.initOptions.preserveDrawBuf = true;
_initGlob.output.initOptions.useCompAssets = false;
_initGlob.output.initOptions.useFullscreen = false;


// initPreloader puzzle
_initGlob.output.initOptions.useCustomPreloader = true;
_initGlob.output.initOptions.preloaderStartCb = function() {
    _initGlob.percentage = 0;
    (function() {})();
};
_initGlob.output.initOptions.preloaderProgressCb = function(percentage) {
    _initGlob.percentage = percentage;
    (function() {
  setHTMLElemAttribute('style', ['Left',Math.round(_initGlob.percentage),'%'].join(''), '', false);
  setHTMLElemAttribute('innerHTML', ['',Math.round(_initGlob.percentage),'%'].join(''), 'loading-value', false);
  setHTMLElemStyle('width', ['Left',Math.round(_initGlob.percentage),'%'].join(''), 'loading-bar-inner', false);
})();
};
_initGlob.output.initOptions.preloaderEndCb = function() {
    _initGlob.percentage = 100;
    (function() {
  setHTMLElemStyle('display', 'none', 'preloader_div', false);
})();
};

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["show_main_annotations"] = show_main_annotations;
this.procedures["add_annotation_main"] = add_annotation_main;
this.procedures["hide_navigation_buttons"] = hide_navigation_buttons;
this.procedures["go_home"] = go_home;
this.procedures["go_back"] = go_back;
this.procedures["sub_industries_selection"] = sub_industries_selection;
this.procedures["hide_main_industries_annotations"] = hide_main_industries_annotations;
this.procedures["hide_sub_industries_annotations"] = hide_sub_industries_annotations;
this.procedures["get_sub_industries_list"] = get_sub_industries_list;
this.procedures["open_web_page"] = open_web_page;
this.procedures["add_annotation_sub_industries"] = add_annotation_sub_industries;
this.procedures["show_internal_blocks"] = show_internal_blocks;
this.procedures["show_navigation"] = show_navigation;
this.procedures["startPreloader"] = startPreloader;
this.procedures["endPreloader"] = endPreloader;
this.procedures["updatePreloader"] = updatePreloader;

var main_blocks, annotation_name, block_name, inception_level, select_camera, industry, selected_industry, sub_industries_annotation_ids, object_name, block, interior_scene, internal_text, internal_text_content, header, home_button, back_button, percentage, annotation_id, sub_industries, selected_sub_industry, sub_industries_objects, application_page, internal_view, i, j, k;

// dictCreateWith puzzle
function dictCreateWith(keys, values) {
    const dict = {};

    keys = Array.isArray(keys) ? keys : keys.split(/\r?\n/).filter(key => key).map(key => key.trim());
    values = Array.isArray(values) ? values : values.split(/\r?\n/).map(key => key.trim());

    for (let i = 0; i < keys.length; i++) {
        dict[keys[i]] = values[i];
    }

    return dict;
}

// dictGet puzzle
function dictGet(dict, key) {
    if (dict && typeof dict == 'object')
        return dict[key];
}

// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}

// Describe this function...
function show_main_annotations() {
  registerSetTimeout(0.2, function() {
    var i_list = ['Industrial', 'Hospital', 'Aerospace', 'Military', 'Semi Conductors', 'eMobility', 'Cloud and Telecom'];
    for (var i_index in i_list) {
      let i = i_list[i_index];
    var VARS = Object.defineProperties({}, {
    'main_blocks': { get: function() { return main_blocks; }, set: function(val) { main_blocks = val; } },
    'annotation_name': { get: function() { return annotation_name; }, set: function(val) { annotation_name = val; } },
    'block_name': { get: function() { return block_name; }, set: function(val) { block_name = val; } },
    'inception_level': { get: function() { return inception_level; }, set: function(val) { inception_level = val; } },
    'select_camera': { get: function() { return select_camera; }, set: function(val) { select_camera = val; } },
    'industry': { get: function() { return industry; }, set: function(val) { industry = val; } },
    'annotation_id': { get: function() { return annotation_id; }, set: function(val) { annotation_id = val; } },
    'internal_view': { get: function() { return internal_view; }, set: function(val) { internal_view = val; } },
    'i': { get: function() { return i; }, set: function(val) { i = val; } },
    'percentage': { get: function() { return percentage; }, set: function(val) { percentage = val; } },
    'sub_industries_annotation_ids': { get: function() { return sub_industries_annotation_ids; }, set: function(val) { sub_industries_annotation_ids = val; } },
    'selected_industry': { get: function() { return selected_industry; }, set: function(val) { selected_industry = val; } },
    'object_name': { get: function() { return object_name; }, set: function(val) { object_name = val; } },
    'sub_industries_objects': { get: function() { return sub_industries_objects; }, set: function(val) { sub_industries_objects = val; } },
    'selected_sub_industry': { get: function() { return selected_sub_industry; }, set: function(val) { selected_sub_industry = val; } },
    'sub_industries': { get: function() { return sub_industries; }, set: function(val) { sub_industries = val; } },
    'block': { get: function() { return block; }, set: function(val) { block = val; } },
    'application_page': { get: function() { return application_page; }, set: function(val) { application_page = val; } },
    'j': { get: function() { return j; }, set: function(val) { j = val; } },
    'header': { get: function() { return header; }, set: function(val) { header = val; } },
    'home_button': { get: function() { return home_button; }, set: function(val) { home_button = val; } },
    'back_button': { get: function() { return back_button; }, set: function(val) { back_button = val; } },
    'interior_scene': { get: function() { return interior_scene; }, set: function(val) { interior_scene = val; } },
    'k': { get: function() { return k; }, set: function(val) { k = val; } },
    'internal_text': { get: function() { return internal_text; }, set: function(val) { internal_text = val; } },
    'internal_text_content': { get: function() { return internal_text_content; }, set: function(val) { internal_text_content = val; } },
});

      add_annotation_main(i, dictGet(main_blocks, i));
    }
  });
}

// createCSSRule puzzle
function createCSSRule(cssRule, cssRuleCont, isParent, mediaRule) {
    var style = document.createElement('style');
    style.type = 'text/css';
    if (mediaRule) {
        style.innerHTML = `@media ${mediaRule} { ${cssRule} { ${cssRuleCont} } }`;
    } else {
        style.innerHTML = `${cssRule} { ${cssRuleCont} }`;
    }

    var styles = (isParent) ? parent.document.getElementsByTagName('head')[0] :
                              document.getElementsByTagName('head')[0];
    styles.appendChild(style)
}

// getEntityByName puzzle
function getEntityByName(name, getWhat) {
    switch (getWhat) {
        case 'OBJECT':
        case 'ANIMATION':
        case 'MATERIAL':
            return name;
        case 'GROUP':
            return ['GROUP', name];
    }
}

function findUniqueObjectName(name) {
    function objNameUsed(name) {
        return Boolean(getObjectByName(name));
    }
    while (objNameUsed(name)) {
        var r = name.match(/^(.*?)(\d+)$/);
        if (!r) {
            name += "2";
        } else {
            name = r[1] + (parseInt(r[2], 10) + 1);
        }
    }
    return name;
}

// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return obj.type !== 'AmbientLight' &&
           obj.name !== '' &&
           !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
           !obj.isAuxClippingMesh;
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = _pGlob !== undefined;
    objFound = runTime ? _pGlob.objCache[objName] : null;

    if (objFound && objFound.name === objName)
        return objFound;

    if (appInstance.scene) {
        appInstance.scene.traverse(function(obj) {
            if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
                objFound = obj;
                if (runTime) {
                    _pGlob.objCache[objName] = objFound;
                }
            }
        });
    }
    return objFound;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc.filter(function(name) {
        return name;
    });
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}

// addAnnotation and removeAnnotation puzzles
function handleAnnot(add, annot, objSelector, contents, id, name) {
    var objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        // check if it already has an annotation and remove it
        for (var j = 0; j < obj.children.length; j++) {
            var child = obj.children[j];
            if (child.type == "Annotation") {
                // delete all childs of annotation
                child.traverse(function(child2) {
                    if (child2.isAnnotation)
                        child2.dispose();
                    });
                obj.remove(child);
            }
        }
        if (add) {
            var aObj = new v3d.Annotation(appInstance.container, annot, contents);
            aObj.name = findUniqueObjectName(name ? name : annot);
            aObj.fadeObscured = _pGlob.fadeAnnotations;
            if (id) {
                aObj.annotation.id = id;
                aObj.annotationDialog.id = id+'_dialog';
            }
            obj.add(aObj);
        }
    }
}

// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}

// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}

// setCSSRuleStyle puzzle
function setCSSRuleStyle(prop, value, id, isParent, mediaRule) {
    var styles = (isParent) ? parent.document.styleSheets : document.styleSheets;
    for (var i = 0; i < styles.length; i++) {
        /**
         * workaround for "DOMException: Failed to read the 'cssRules' property
         * from 'CSSStyleSheet': Cannot access rules"
         */
        try { var cssRules = styles[i].cssRules; }
        catch (e) { continue; }

        for (var j = 0; j < cssRules.length; j++) {
            var cssRule = cssRules[j];
            if (!mediaRule && cssRule.selectorText == id)
                cssRule.style[prop] = value;
            else if (mediaRule && cssRule.media && cssRule.media.mediaText == mediaRule) {
                var cssRulesMedia = cssRule.cssRules;
                for (var k = 0; k < cssRulesMedia.length; k++) {
                    if (cssRulesMedia[k].selectorText == id)
                        cssRulesMedia[k].style[prop] = value;
                }
            }
        }
    }
}

// Describe this function...
function add_annotation_main(annotation_name, block_name) {
  createCSSRule('.main_annotation', 'caret-color: transparent;', false, '');
  handleAnnot(true, annotation_name, getEntityByName(block_name, 'OBJECT'), '', dictGet(annotation_id, annotation_name), undefined);
  setHTMLElemAttribute('className', 'main_annotation', dictGet(annotation_id, annotation_name), false);
  setCSSRuleStyle('position', 'absolute', '.main_annotation', false, '');
  setCSSRuleStyle('backgroundColor', '#003057', '.main_annotation', false, '');
  setCSSRuleStyle('color', '#ffffff', '.main_annotation', false, '');
  setCSSRuleStyle('borderRadius', '8px', '.main_annotation', false, '');
  setCSSRuleStyle('fontFamily', '"Arial"', '.main_annotation', false, '');
  setCSSRuleStyle('fontSize', '16px', '.main_annotation', false, '');
  setCSSRuleStyle('padding', '12px', '.main_annotation', false, '');
  setCSSRuleStyle('width', 'auto', '.main_annotation', false, '');
  setCSSRuleStyle('cursor', 'pointer', '.main_annotation', false, '');
  setCSSRuleStyle('zIndex', '100', '.main_annotation', false, '');
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}

// Describe this function...
function hide_navigation_buttons() {
  setHTMLElemStyle('display', 'none', 'button_container', false);
  setHTMLElemStyle('display', 'none', 'internal-header-text', false);
}

// setActiveCamera puzzle
function setActiveCamera(camName) {
    var camera = getObjectByName(camName);
    if (!camera || !camera.isCamera || appInstance.getCamera() == camera)
        return;
    appInstance.setCamera(camera);
}

/**
 * Retrieve coordinate system from the loaded scene
 */
function getCoordSystem() {
    var scene = appInstance.scene;

    if (scene && 'coordSystem' in scene.userData) {
        return scene.userData.coordSystem;
    }

    return 'Y_UP_RIGHT';
}


/**
 * Transform coordinates from one space to another
 * Can be used with Vector3 or Euler.
 */
function coordsTransform(coords, from, to, noSignChange) {

    if (from == to)
        return coords;

    var y = coords.y, z = coords.z;

    if (from == 'Z_UP_RIGHT' && to == 'Y_UP_RIGHT') {
        coords.y = z;
        coords.z = noSignChange ? y : -y;
    } else if (from == 'Y_UP_RIGHT' && to == 'Z_UP_RIGHT') {
        coords.y = noSignChange ? z : -z;
        coords.z = y;
    } else {
        console.error('coordsTransform: Unsupported coordinate space');
    }

    return coords;
}


/**
 * Verge3D euler rotation to Blender/Max shortest.
 * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
 *    order) via reversion: XYZ -> ZYX
 * 2) swizzle ZYX->YZX
 * 3) choose the shortest rotation to resemble Blender's behavior
 */
const eulerV3DToBlenderShortest = function() {

    const eulerTmp = new v3d.Euler();
    const eulerTmp2 = new v3d.Euler();
    const vec3Tmp = new v3d.Vector3();

    return function(euler, dest) {

        const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
        const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

        const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
        const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();

        dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
        return coordsTransform(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
    }

}();

// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = coordsTransform(worldPos, getCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = coordsTransform(worldTarget, getCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}

// loadScene puzzle
function loadScene(url, sceneName, loadCb, progCb, errorCb) {

    appInstance.unload();

    // clean object cache
    _pGlob.objCache = {};

    _pGlob.percentage = 0;
    appInstance.loadScene(url, function(loadedScene) {
        appInstance.enableControls();
        loadedScene.name = sceneName;

        _pGlob.percentage = 100;
        loadCb();
    }, function(percentage) {
        _pGlob.percentage = percentage;
        progCb();
    }, errorCb);
}

// setCameraParam puzzle
function setCameraParam(type, objSelector, param) {

    var objNames = retrieveObjectNames(objSelector);

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        var obj = getObjectByName(objName);
        if (!obj || !obj.isCamera) return;

        if (!(obj.isPerspectiveCamera || obj.isOrthographicCamera)) {
            console.error('setCameraParam: Incompatible camera type, have to be perspective or orthographic');
            return;
        }

        let isSetOrbitParam = false;
        switch (type) {
            case 'ORBIT_MIN_DISTANCE_PERSP':
            case 'ORBIT_MAX_DISTANCE_PERSP':
            case 'ORBIT_MIN_ZOOM_ORTHO':
            case 'ORBIT_MAX_ZOOM_ORTHO':
            case 'ORBIT_MIN_VERTICAL_ANGLE':
            case 'ORBIT_MAX_VERTICAL_ANGLE':
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
            case 'ORBIT_ALLOW_TURNOVER':
                isSetOrbitParam = true;
                break;
        }
        let isSetControlsParam = (['ROTATION_SPEED', 'MOVEMENT_SPEED', 'ALLOW_PANNING', 'ALLOW_ZOOM', 'KEYBOARD_CONTROLS'].includes(type) || isSetOrbitParam);
        if (isSetControlsParam) {
            if (!obj.controls) {
                console.error('setCameraParam: The "' + objName +'" camera has no controller');
                return;
            } else if (isSetOrbitParam && obj.controls.type != 'ORBIT') {
                console.error('setCameraParam: Incompatible camera controller');
                return;
            }
        }

        switch (type) {
            case 'FIELD_OF_VIEW':
                if (obj.isPerspectiveCamera) {
                    obj.fov = param;
                    obj.updateProjectionMatrix();
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORTHO_SCALE':
                if (obj.isOrthographicCamera) {
                    obj.zoom = param;
                    obj.updateProjectionMatrix();
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ROTATION_SPEED':
                obj.controls.rotateSpeed = param;
                break;
            case 'MOVEMENT_SPEED':
                obj.controls.moveSpeed = param;
                break;
            case 'ALLOW_PANNING':
                obj.controls.enablePan = param;
                break;
            case 'ALLOW_ZOOM':
                obj.controls.enableZoom = param;
                break;
            case 'KEYBOARD_CONTROLS':
                obj.controls.enableKeys = param;
                break;
            case 'ORBIT_MIN_DISTANCE_PERSP':
                if (obj.isPerspectiveCamera) {
                    obj.controls.orbitMinDistance = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MAX_DISTANCE_PERSP':
                if (obj.isPerspectiveCamera) {
                    obj.controls.orbitMaxDistance = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MIN_ZOOM_ORTHO':
                if (obj.isOrthographicCamera) {
                    obj.controls.orbitMinZoom = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MAX_ZOOM_ORTHO':
                if (obj.isOrthographicCamera) {
                    obj.controls.orbitMaxZoom = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MIN_VERTICAL_ANGLE':
                obj.controls.orbitMinPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_VERTICAL_ANGLE':
                obj.controls.orbitMaxPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
                obj.controls.orbitMinAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
                obj.controls.orbitMaxAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_ALLOW_TURNOVER':
                obj.controls.orbitEnableTurnover = param;
                break;
            case 'CLIP_START':
                obj.near = param;
                obj.updateProjectionMatrix();
                break;
            case 'CLIP_END':
                obj.far = param;
                obj.updateProjectionMatrix();
                break;
        }

        if (isSetControlsParam)
            appInstance.enableControls();

    });
}

// Describe this function...
function go_home() {
  setActiveCamera('Main_camera');
  if (inception_level == 1) {
    tweenCamera('empty_main_camera', 'empty_center', 1.5, function() {}, 1);
    inception_level = 0;
    show_main_annotations();
    sub_industries_selection();
    hide_navigation_buttons();
  } else {
    startPreloader();
    loadScene('boyd_smart_city.gltf', 'boyd_smart_city.gltf', function() {
      endPreloader();
      setHTMLElemStyle('display', 'none', 'main_container', false);
      setHTMLElemStyle('display', 'none', 'internal_header_text', false);
      show_main_annotations();
      sub_industries_selection();
      hide_navigation_buttons();
    }, function() {
      updatePreloader(Math.round(_pGlob.percentage));
    }, function() {});
    inception_level = 0;
  }
  setCameraParam('ALLOW_ZOOM', 'Main_camera', true);
  hide_sub_industries_annotations();
}

// getActiveCamera puzzle
function getActiveCamera() {
    var camera = appInstance.getCamera();
    return camera.name;
}

// Describe this function...
function go_back(industry) {
  startPreloader();
  loadScene('boyd_smart_city.gltf', 'boyd_smart_city.gltf', function() {
    show_main_annotations();
    sub_industries_selection();
    hide_navigation_buttons();
  }, function() {
    updatePreloader(Math.round(_pGlob.percentage));
    endPreloader();
    setHTMLElemStyle('display', 'none', 'main_container', false);
    setHTMLElemStyle('display', 'none', 'internal_header_text', false);
    setActiveCamera(dictGet(select_camera, industry));
    registerSetTimeout(0.2, function() {
      tweenCamera('', 'empty_industrial', 1, function() {}, 0);
    });
  }, function() {});
  setCameraParam('ALLOW_ZOOM', getActiveCamera(), true);
}

// Describe this function...
function get_sub_industries_list(industry) {
  sub_industries = [];
  if (industry == 'annotation_aerospace') {
    sub_industries = ['Avionics Thermal Chassis', 'Engine Heat Exchanger', 'In Flight Entertainment HMI', 'Instrument Panel HMI', 'Flame Barrier Insulation'];
  } else if (industry == 'annotation_industrial') {
    sub_industries = ['Industrial Automation'];
  } else if (industry == 'annotation_semiconductors') {
    sub_industries = ['Semiconductors'];
  } else if (industry == 'Semiconductors Internal') {
    sub_industries = ['Test Sockets', 'Chillers', 'Thermal Test Systems', 'Wafer Processing Solutions'];
  } else if (industry == 'Industrial Automation') {
    sub_industries = ['Industrial HMI', 'Motor Drive Solutions', '3D Printing and Laser Solutions', 'Robotics Solutions'];
  }
}

// getEventProperty puzzle
function getEventProperty(prop, event) {
    if (typeof event != "undefined") {
        switch (prop) {
            case 'target.checked':
                return event.target.checked;
            case 'target.id':
                return event.target.id;
            case 'target.value':
                return event.target.value;
            case 'touches.length':
                return event.touches ? event.touches.length : 0;
            case 'touches[0].pageX':
                return event.touches[0].pageX;
            case 'touches[0].pageY':
                return event.touches[0].pageY;
            case 'touches[1].pageX':
                return event.touches[1].pageX;
            case 'touches[1].pageY':
                return event.touches[1].pageY;
            case 'targetTouches.length':
                return event.targetTouches ? event.targetTouches.length : 0;
            case 'targetTouches[0].pageX':
                return event.targetTouches[0].pageX;
            case 'targetTouches[0].pageY':
                return event.targetTouches[0].pageY;
            case 'targetTouches[1].pageX':
                return event.targetTouches[1].pageX;
            case 'targetTouches[1].pageY':
                return event.targetTouches[1].pageY;
            default:
                return event[prop];
        }
    }
}

// zoomCamera puzzle
function zoomCamera(objSelector, duration, doSlot) {

    duration = Math.max(0, duration);

    const objNames = retrieveObjectNames(objSelector);

    const zoomObjects = [];
    objNames.forEach(function(name) {
        const obj = getObjectByName(name);
        if (obj) {
            zoomObjects.push(obj);
        }
    });

    if (!zoomObjects.length) {
        return;
    }

    const camera = appInstance.getCamera();

    const zoom = [camera.zoom]; // for orthographic camera only

    const pos = _pGlob.vec3Tmp, target = _pGlob.vec3Tmp2;
    v3d.CameraUtils.calcCameraZoomToObjectsParams(camera, zoomObjects,
            pos, target, zoom);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            if (camera.isOrthographicCamera) {
                appInstance.controls.tweenZoomTo(target, zoom[0],
                        duration, doSlot);
            } else {
                appInstance.controls.tween(pos, target, duration, doSlot);
            }
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(pos);
        }
        camera.position.copy(pos);
        camera.lookAt(target);
        camera.zoom = zoom[0];
        camera.updateProjectionMatrix();
        doSlot();
    }
}

function _checkListenersSame(target0, type0, listener0, optionsOrUseCapture0,
        target1, type1, listener1, optionsOrUseCapture1) {
    const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
            ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
    const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
            ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
    return target0 === target1 && type0 === type1 && listener0 === listener1
            && capture0 === capture1;
}

/**
 * Add the specified event listener to the specified target. This function also
 * stores listener data for easier disposing.
 */
function bindListener(target, type, listener, optionsOrUseCapture) {
    const alreadyExists = _pGlob.eventListeners.some(elem => {
        return _checkListenersSame(elem.target, elem.type, elem.listener,
                elem.optionsOrUseCapture, target, type, listener,
                optionsOrUseCapture);
    });

    if (!alreadyExists) {
        target.addEventListener(type, listener, optionsOrUseCapture);
        _pGlob.eventListeners.push({ target, type, listener, optionsOrUseCapture });
    }
}

// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;

        bindListener(elem, eventType, callback);
    }
}

// Describe this function...
function sub_industries_selection() {
  registerSetTimeout(1, function() {
    eventHTMLElem('click', ['annotation_hospital', 'annotation_industrial', 'annotation_aerospace', 'annotation_military', 'annotation_semiconductors', 'annotation_eMobility', 'annotation_cloud'], false, function(event) {
      inception_level = 1;
      hide_main_industries_annotations();
      selected_industry = getEventProperty('target.id', event);
      zoomCamera(getEntityByName(dictGet(block, getEventProperty('target.id', event)), 'GROUP'), 2, function() {
        get_sub_industries_list(getEventProperty('target.id', event));
        for (var j_index in sub_industries) {
          let j = sub_industries[j_index];
        var VARS = Object.defineProperties({}, {
    'main_blocks': { get: function() { return main_blocks; }, set: function(val) { main_blocks = val; } },
    'annotation_name': { get: function() { return annotation_name; }, set: function(val) { annotation_name = val; } },
    'block_name': { get: function() { return block_name; }, set: function(val) { block_name = val; } },
    'inception_level': { get: function() { return inception_level; }, set: function(val) { inception_level = val; } },
    'select_camera': { get: function() { return select_camera; }, set: function(val) { select_camera = val; } },
    'industry': { get: function() { return industry; }, set: function(val) { industry = val; } },
    'annotation_id': { get: function() { return annotation_id; }, set: function(val) { annotation_id = val; } },
    'internal_view': { get: function() { return internal_view; }, set: function(val) { internal_view = val; } },
    'i': { get: function() { return i; }, set: function(val) { i = val; } },
    'percentage': { get: function() { return percentage; }, set: function(val) { percentage = val; } },
    'sub_industries_annotation_ids': { get: function() { return sub_industries_annotation_ids; }, set: function(val) { sub_industries_annotation_ids = val; } },
    'selected_industry': { get: function() { return selected_industry; }, set: function(val) { selected_industry = val; } },
    'object_name': { get: function() { return object_name; }, set: function(val) { object_name = val; } },
    'sub_industries_objects': { get: function() { return sub_industries_objects; }, set: function(val) { sub_industries_objects = val; } },
    'selected_sub_industry': { get: function() { return selected_sub_industry; }, set: function(val) { selected_sub_industry = val; } },
    'sub_industries': { get: function() { return sub_industries; }, set: function(val) { sub_industries = val; } },
    'block': { get: function() { return block; }, set: function(val) { block = val; } },
    'application_page': { get: function() { return application_page; }, set: function(val) { application_page = val; } },
    'j': { get: function() { return j; }, set: function(val) { j = val; } },
    'header': { get: function() { return header; }, set: function(val) { header = val; } },
    'home_button': { get: function() { return home_button; }, set: function(val) { home_button = val; } },
    'back_button': { get: function() { return back_button; }, set: function(val) { back_button = val; } },
    'interior_scene': { get: function() { return interior_scene; }, set: function(val) { interior_scene = val; } },
    'k': { get: function() { return k; }, set: function(val) { k = val; } },
    'internal_text': { get: function() { return internal_text; }, set: function(val) { internal_text = val; } },
    'internal_text_content': { get: function() { return internal_text_content; }, set: function(val) { internal_text_content = val; } },
});

          add_annotation_sub_industries(j, dictGet(sub_industries_objects, j));
        }
        show_internal_blocks();
        open_web_page();
        show_navigation(null, false, true, false);
      });
      setHTMLElemAttribute('title', 'industrial_test', 'annotation_industrial', false);
    });
  });
}

// Describe this function...
function hide_main_industries_annotations() {
  setHTMLElemStyle('display', 'none', ['annotation_hospital', 'annotation_industrial', 'annotation_aerospace', 'annotation_military', 'annotation_semiconductors', 'annotation_eMobility', 'annotation_cloud'], false);
}

// Describe this function...
function hide_sub_industries_annotations() {
  setHTMLElemStyle('display', 'none', ['Avionics Thermal Chassis', 'Engine Heat Exchanger', 'In Flight Entertainment HMI', 'Instrument Panel HMI', 'Flame Barrier Insulation', 'Industrial Automation', 'Semiconductors Internal'], false);
}

// openWebPage puzzle
function openWebPage(url, mode) {

    if (appInstance && appInstance.controls) {
        appInstance.controls.forceMouseUp();
    }

    if (mode == "NEW") {
        window.open(url);
    } else if (mode == "NO_RELOAD") {
        history.pushState('verge3d state', 'verge3d page', url);
    } else {
        var target;
        switch (mode) {
            case "SAME":
                target = "_self";
                break;
            case "TOP":
                target = "_top";
                break;
            case "PARENT":
                target = "_parent";
                break;
        }

        window.open(url, target);

    }
}

// Describe this function...
function open_web_page() {
  eventHTMLElem('click', ['Avionics Thermal Chassis', 'Engine Heat Exchanger', 'In Flight Entertainment HMI', 'Instrument Panel HMI', 'Flame Barrier Insulation', 'Robotics Solutions', 'Motor Drive Solutions', '3D Printing and Laser Solutions', 'Industrial HMI'], false, function(event) {
    openWebPage(dictGet(application_page, getEventProperty('target.id', event)), 'NEW');
  });
}

// Describe this function...
function add_annotation_sub_industries(annotation_name, object_name) {
  createCSSRule('.sub_annotation', 'caret-color: transparent;', false, '');
  handleAnnot(true, annotation_name, getEntityByName(object_name, 'OBJECT'), '', dictGet(sub_industries_annotation_ids, annotation_name), undefined);
  setHTMLElemAttribute('className', 'sub_annotation', dictGet(sub_industries_annotation_ids, annotation_name), false);
  setCSSRuleStyle('display', 'block', '.sub_annotation', false, '');
  setCSSRuleStyle('position', 'absolute', '.sub_annotation', false, '');
  setCSSRuleStyle('backgroundColor', '#E0673C', '.sub_annotation', false, '');
  setCSSRuleStyle('color', '#ffffff', '.sub_annotation', false, '');
  setCSSRuleStyle('borderRadius', '8px', '.sub_annotation', false, '');
  setCSSRuleStyle('fontFamily', '"Arial"', '.sub_annotation', false, '');
  setCSSRuleStyle('fontSize', '16px', '.sub_annotation', false, '');
  setCSSRuleStyle('padding', '8px', '.sub_annotation', false, '');
  setCSSRuleStyle('width', 'auto', '.sub_annotation', false, '');
  setCSSRuleStyle('cursor', 'pointer', '.sub_annotation', false, '');
  setCSSRuleStyle('opacity', '1', '.sub_annotation', false, '');
}

// Describe this function...
function show_internal_blocks() {
  eventHTMLElem('click', ['Industrial Automation', 'Medical Solutions', 'Vehicle Solutions', 'Data Center Solutions', 'Semiconductors Internal'], false, function(event) {
    startPreloader();
    loadScene(dictGet(interior_scene, getEventProperty('target.id', event)), dictGet(interior_scene, getEventProperty('target.id', event)), function() {
      endPreloader();
      get_sub_industries_list(getEventProperty('target.id', event));
      for (var k_index in sub_industries) {
        let k = sub_industries[k_index];
      var VARS = Object.defineProperties({}, {
    'main_blocks': { get: function() { return main_blocks; }, set: function(val) { main_blocks = val; } },
    'annotation_name': { get: function() { return annotation_name; }, set: function(val) { annotation_name = val; } },
    'block_name': { get: function() { return block_name; }, set: function(val) { block_name = val; } },
    'inception_level': { get: function() { return inception_level; }, set: function(val) { inception_level = val; } },
    'select_camera': { get: function() { return select_camera; }, set: function(val) { select_camera = val; } },
    'industry': { get: function() { return industry; }, set: function(val) { industry = val; } },
    'annotation_id': { get: function() { return annotation_id; }, set: function(val) { annotation_id = val; } },
    'internal_view': { get: function() { return internal_view; }, set: function(val) { internal_view = val; } },
    'i': { get: function() { return i; }, set: function(val) { i = val; } },
    'percentage': { get: function() { return percentage; }, set: function(val) { percentage = val; } },
    'sub_industries_annotation_ids': { get: function() { return sub_industries_annotation_ids; }, set: function(val) { sub_industries_annotation_ids = val; } },
    'selected_industry': { get: function() { return selected_industry; }, set: function(val) { selected_industry = val; } },
    'object_name': { get: function() { return object_name; }, set: function(val) { object_name = val; } },
    'sub_industries_objects': { get: function() { return sub_industries_objects; }, set: function(val) { sub_industries_objects = val; } },
    'selected_sub_industry': { get: function() { return selected_sub_industry; }, set: function(val) { selected_sub_industry = val; } },
    'sub_industries': { get: function() { return sub_industries; }, set: function(val) { sub_industries = val; } },
    'block': { get: function() { return block; }, set: function(val) { block = val; } },
    'application_page': { get: function() { return application_page; }, set: function(val) { application_page = val; } },
    'j': { get: function() { return j; }, set: function(val) { j = val; } },
    'header': { get: function() { return header; }, set: function(val) { header = val; } },
    'home_button': { get: function() { return home_button; }, set: function(val) { home_button = val; } },
    'back_button': { get: function() { return back_button; }, set: function(val) { back_button = val; } },
    'interior_scene': { get: function() { return interior_scene; }, set: function(val) { interior_scene = val; } },
    'k': { get: function() { return k; }, set: function(val) { k = val; } },
    'internal_text': { get: function() { return internal_text; }, set: function(val) { internal_text = val; } },
    'internal_text_content': { get: function() { return internal_text_content; }, set: function(val) { internal_text_content = val; } },
});

        add_annotation_sub_industries(k, dictGet(sub_industries_objects, k));
      }
      show_navigation(getEventProperty('target.id', event), true, true, true);
      open_web_page();
      inception_level = 2;
    }, function() {
      updatePreloader(Math.round(_pGlob.percentage));
    }, function() {});
  });
}

// Describe this function...
function show_navigation(internal_text_content, header, home_button, back_button) {
  setHTMLElemStyle('display', 'flex', 'main_container', true);
  setHTMLElemStyle('display', 'flex', 'button_container', true);
  setHTMLElemStyle('display', 'block', 'home_button', true);
  if (header == true) {
    setHTMLElemStyle('display', 'block', 'internal_header_text', true);
    setHTMLElemAttribute('innerHTML', internal_text_content, 'internal_text', true);
    setHTMLElemStyle('display', 'flex', 'internal_text', true);
  } else {
    setHTMLElemStyle('display', 'none', 'internal_header_text', true);
    setHTMLElemStyle('display', 'none', 'internal_text', true);
  }
  if (back_button == true) {
    setHTMLElemStyle('display', 'block', 'back_button', true);
  } else {
    setHTMLElemStyle('display', 'none', 'back_button', true);
  }
}

// Describe this function...
function startPreloader() {
  setHTMLElemStyle('filter', 'blur(1000px)', ['QUERYSELECTOR', '#v3d-container > canvas'], false);
  registerSetTimeout(0.1, function() {
    setHTMLElemStyle('display', 'block', 'preloader', false);
    setHTMLElemStyle('width', '0%', 'preloader_bar', false);
  });
}

// Describe this function...
function endPreloader() {
  registerSetTimeout(0.1, function() {
    setHTMLElemStyle('filter', 'blur(0px)', ['QUERYSELECTOR', '#v3d-container > canvas'], false);
    setHTMLElemStyle('display', 'none', 'preloader', false);
  });
}

// Describe this function...
function updatePreloader(percentage) {
  setHTMLElemStyle('width', String(percentage) + '%', 'preloader_bar', false);
}


show_main_annotations();
hide_navigation_buttons();

main_blocks = dictCreateWith(['Hospital', 'Industrial', 'Aerospace', 'Military', 'Semi Conductors', 'eMobility', 'Cloud and Telecom'], ['empty_hospital', 'empty_industrial', 'empty_airport', 'empty_military', 'empty_semiconductors', 'empty_EV', 'empty_cloud']);
annotation_id = dictCreateWith(['Hospital', 'Industrial', 'Aerospace', 'Military', 'Semi Conductors', 'eMobility', 'Cloud and Telecom'], ['annotation_hospital', 'annotation_industrial', 'annotation_aerospace', 'annotation_military', 'annotation_semiconductors', 'annotation_eMobility', 'annotation_cloud']);
internal_view = dictCreateWith(['Hospital', 'Industrial', 'Aerospace', 'Military', 'Semi Conductors', 'eMobility', 'Cloud and Telecom'], ['true', 'true', 'false', 'false', 'true', 'true', 'true']);

setActiveCamera('Main_camera');

inception_level = 0;

select_camera = dictCreateWith(['Hospital', 'Industrial', 'Aerospace', 'Military', 'Semi Conductors', 'eMobility', 'Cloud and Telecom'], ['Hospital', 'Camera_Industrial', 'Aerospace', 'Military', 'Semi Conductors', 'eMobility', 'Cloud and Telecom']);

console.log('Hello, Verge!');

selected_industry = 'null';
selected_sub_industry = 'null';

sub_industries_selection();

sub_industries_annotation_ids = dictCreateWith(['Avionics Thermal Chassis', 'Engine Heat Exchanger', 'In Flight Entertainment HMI', 'Instrument Panel HMI', 'Flame Barrier Insulation', 'Industrial Automation', 'Industrial HMI', 'Motor Drive Solutions', '3D Printing and Laser Solutions', 'Robotics Solutions', 'Semiconductors', 'Test Sockets', 'Thermal Test Systems', 'Wafer Processing Solutions', 'Chillers'], ['Avionics Thermal Chassis', 'Engine Heat Exchanger', 'In Flight Entertainment HMI', 'Instrument Panel HMI', 'Flame Barrier Insulation', 'Industrial Automation', 'Industrial HMI', 'Motor Drive Solutions', '3D Printing and Laser Solutions', 'Robotics Solutions', 'Semiconductors Internal', 'Test Sockets', 'Thermal Test Systems', 'Wafer Processing Solutions', 'Chillers']);
sub_industries_objects = dictCreateWith(['Avionics Thermal Chassis', 'Engine Heat Exchanger', 'In Flight Entertainment HMI', 'Instrument Panel HMI', 'Flame Barrier Insulation', 'Industrial Automation', 'Robotics Solutions', 'Motor Drive Solutions', '3D Printing and Laser Solutions', 'Industrial HMI', 'Semiconductors', 'Test Sockets', 'Thermal Test Systems', 'Wafer Processing Solutions', 'Chillers'], ['Airplane', 'empty_airplane', 'Airplane.003', 'Airplane.002', 'Flame_Barrier_Insulation', 'Empty_Industrial_Automation', 'drone', 'Motor_Drive_Solutions', '3D Printing', 'HMI', 'empty_semiconductors_internal', 'test_sockets', 'thermal_test_systems', 'wafer_processing_solutions', 'chillers']);

block = dictCreateWith(['annotation_industrial', 'annotation_hospital', 'annotation_aerospace', 'annotation_military', 'annotation_semiconductors', 'annotation_eMobility', 'annotation_cloud'], ['industry', 'HOSPITAL', 'Aerospace', 'Defence', 'Semi_Conductor', 'E-MOBILITY_POWER', 'TELECOM']);
application_page = dictCreateWith(['Avionics Thermal Chassis', 'Engine Heat Exchanger', 'In Flight Entertainment HMI', 'Instrument Panel HMI', 'Flame Barrier Insulation', null, 'Robotics Solutions', 'Motor Drive Solutions', '3D Printing and Laser Solutions', 'Industrial HMI'], ['https://www.boydcorp.com/industries/aerospace-defense.html', 'https://www.boydcorp.com/industries/aerospace-defense.html', 'https://www.boydcorp.com/industries/aerospace-defense.html', 'https://www.boydcorp.com/industries/aerospace-defense.html', 'https://www.boydcorp.com/industries/aerospace-defense.html', null, 'https://www.boydcorp.com/industries/industrial.html', 'https://www.boydcorp.com/industries/automotive.html', 'https://www.boydcorp.com/industries/consumer-electronics.html', 'https://www.boydcorp.com/engineered-materials/surface-protection-enhancement/display-enhancement-protection.html', null]);

interior_scene = dictCreateWith(['Industrial Automation', 'Medical Solutions', 'Vehicle Solutions', 'Data Center Solutions', 'Semiconductors Internal'], ['industrial_internal.gltf', 'interior_industrial.gltf', 'interior_industrial.gltf', 'interior_industrial.gltf', 'semiconductor_internal.gltf']);

eventHTMLElem('click', ['home_button', 'back_button'], false, function(event) {
  if (getEventProperty('target.id', event) == 'home_button') {
    go_home();
  } else {
    go_back(selected_industry);
  }
});

internal_text = dictCreateWith(['Industrial Automation', 'Medical Solutions', 'Vehicle Solutions', 'Data Center Solutions', 'Semiconductors Internal'], ['Industrial Automation', 'Medical Solutions', 'Vehicle Solutions', 'Data Center Solutions', 'Semiconductors Internal']);

'flex';



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
